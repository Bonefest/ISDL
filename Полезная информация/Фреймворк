MSDL - Modern SDL. Является обёрткой обычного SDL,добавляет более высокий слой абстракции , благодаря применению принципов ООП.

Версия компилятор 4.96 не работала (по крайней мере на моем компьютере, по этому лучше установить хотя бы 6 и компилить с ней : sudo apt-get install g++-6 ; g++-6 file.name)


К ключевые моменты,которые добавляет MSDL:

+Игра - главный класс,который хранит необходимую информацию об всей игре.Хранит набор сцен и оперирует ими.Является синглтоном,т.е имеет всего один экземпляр на всю игру.
+Сцена - класс,который отображает логику игрового уровня.Так же фактически представляет конкретный уровень.Является абстрактным классом,который должен быть переопределен.

Пробегает по всем спрайтам сцены и в случае isClicked вызывает событие данного спрайта onClick,а так же добавляет их в временный контейнер clickedSprites , который при событии отпускания мыши вызывает onReleased()

При событии движения мыши,проверяем принадлежит ли координата мыши спрайту,в случае истины - вызываем событие onHovered

*Камера	- класс,который хранит собственные координаты,по сути является игровым объектом и который может перемещаться.Все объекты отображаются относительно этого объекта.Это означает,что если камера в позиции (0,0),то всё отображается в привычном для нас виде,если же камера сдвинется вправо на 10 единиц,то все объекты сдвинутся влево на 10 единиц.

Камера является точно таким же объектом,как кнопка или монстр,она является частью сцены,а не всей игры,из-за этого ответственность за отображение всех объектов возлагается на конкретную сцену.

*Спрайт - класс,который определяет объект,являющийся частью сцены.Является базовым классом для всех отображаемых элементов игры : Граф.Интерфейс,Существа,Объекты,Вещи и т.д.Хранит позицию,текстуру,размер и т.д.Фактически является обёрткой SDL_Texture.

Событие onClick спрайта вызывается,если в контроллере сцены при событии mousedown спрайт вернул истину при проверке isClicked.

Должны ли мы хранить состояния bool pressed , bool hovered ?


*Игровой объект


*Интерфейс - набор базовых элементов интерфейса: кнопки,скролбары,вкладки и т.д.

Почти каждый элемент интерфейса наследует класс Sprite,который представляет изображаемый объект в мире игры.
Основные элементы интерфейса:

Окно - представляет контейнер,который хранит другие элементы и отрисовывает каждый из них.
Кнопка - представляет кнопку,которая принимает некоторую callback-функцию и другие данные для отображения и внешнего вида.
Скроллбар - представляет набор из двух кнопок и полосы,которые связаны с заданным окном.
Поле ввода

Элементы интерфейса можно разделить на монолитные,составные, и контейнеры.



*Анимация - добавляет несколько классов для работы с анимацией


*ActionManager - синглтон,который принимает объект (к примеру спрайт) благодаря специализированным функциям (пример ActionManager::Move) и выполняет заданное действие.

Основные функции ActionManager'a: 

1.Move - двигает объект в заданную точку за заданное время.
2.MoveBy - двигает объект в заданную точку относительно текущей позиции за заданное время.
3.Tint - красит объект в заданный цвет за заданное время.
4.Rotate - поворачивает объект в заданном направлении на заданный угол за заданное время.
5.RotateBy - поворачивает объект в заданном направлении на заданый угол относительно текущего за заданное время.
6.Use - вызывает функцию спустя заданное время.
7.

*MediaManager - синглтон,который принимает имя текстуры и возвращает текстуру целиком (getTexture) , либо часть текстуры,в случае работы с атласом (getPartTexture).Так же умеет читать json файлы для инициализации текстурами,указанными во внешних файлах.Всю информацию хранит в map ,где ключ - это имя текстуры,а значение - структура TextureInfo ,которая состоит из SDL_Rect,описывающем положение части изображения на текстуре и самой текстуры


+Логирование - добавление всей происходящей с игрой информации в лог



Отрисовка происходит по следующей цепочке : Игра-Сцена(Рисует все объекты,которые принадлежит сцене относительно камер)-Спрайт-Анимация

(БУДУЩЕЕ) Добавление спрайтов на сцену сразу сортируется по расстоянию до центра.

(БУДУЩЕЕ) Добавление спрайтов на сцену может осуществляется с помощью ещё одной функции,которая определяет какие объекты будут рисоваться первыми,а какие - последними.

(БУДУЩЕЕ) Поле обзора камеры 

(БУДУЩЕЕ) Сохранять вместо последней точки нажатой мыши,целое событие.Тогда мы сможем получать кроме всего того дополнительную информацию (например кол-во кликов).

(БУДУЩЕЕ) Камера отцентровывает свой объект по размеру,заданному в game.h , в будущем добавить viewport и соответственно размер его и положение.

(БУДУЩЕЕ) Сейчас для отображения графического интерфейса,необходимо добавить граф. элемент как любой другой спрайт к камеры сцены.Возможно лучше сделать возможность добавления граф.элементов через отдельный интерфейс,что-то в духе addUserInterfaceElement.

(РЕШЕНО) функция getPressedTime работает не так как нужно,вероятно проблема в erase (функция возвращает всегда -1,кроме 1го раза).

(ВОЗМОЖНО) если игра сильно зависает deltaTime становится очень большим,при этом анимация в любом случае перекидывается на 1 кадр.

Закончил на нажатии на спрайт.Суть в том,что позиция спрайта - абсолютная,для клика нужно как-то получать относительные координаты. (Как вариант,передвигать клик в позицию камеры и уже так считать)

Приложения для иллюстрации работы:


1.Генератор случайно падающих квадратов,которые создают в конце некую гору
-----------------------------------------------------------------------------------------------------------

Фреймворк. План разработки

*Разработка media_manager'a
	
	Следует внедрить возможность подгрузки метаданных: позиция,размер на атласе , различных изображений. Метаданные должны храниться в json файлах. Главное преимущество такого подхода : возможность зная имя некого json'a, загрузить сразу всю необходимую информацию про позицию различных изображений, анимаций и т.д, не перегружая код лишними операциями. Другое преимущество - возможность без компиляции менять изображения.
	
	Загрузка анимаций. Сейчас это полный треш, вряд ли кому-то понравиться в программном коде видеть странные функции создания анимаций с явно заданными границами атласа и другими данными. Медиа менеджер должен помочь функцией getAnimation(std::string name), которая вернет уже свежую анимаций, готовую к использованию спрайтом. Вообще анимации сейчас немного странно используются (или нет?): мы создаем анимацию, сохраняем её в некий массив анимаций спрайта, и при инициализации так же добавляем спрайту все загруженные анимации. Новый функционал помогает избавить от необходимости вручную загружать инфу о анимациях и заменить всё простой коммандой getAnimation, в случае необходимости изменения некоторых данных об анимации (скорость,зацикленность), мы можем просто-напросто получить анимацию,а затем уже изменить её параметры (возвращается копия анимации).

ГОТОВО.Теперь анимации загружаются посредством json файлов (но это не означает,что это единственный способ:
	1.Загрузка с помощью JSON файлов.
	2.Загрузка вручную с помощью медиа менедждера
	3.Забыть от медиа менеджере и использовать напрямую файл animation.h
)
-----------------------------------------------------------------------------------------------------------

*Разработка sprite'a

	Необходимо добавить новые данные в sprite: дочерние и родительские объекты,благодаря которым пользователь может упростить относительное позицинирование.Дети,при передвижении их родительского объекта, изменяют свою позицию ровно на столько же,т.е они как бы "привязаны" к своему родителю.При этом,разумеется, изменение позиции дочернего объекта никак не влияет на позицию родителя.

	Основное предназначение дочерних и родительских объектов - упростить управление множеством взаимосвязанных объектов. Представим, что у нас есть игровой персонаж,на котором отображается шлем,туловище и штаны. Если мы добавим эти спрайты как дочерние некому объекту "персонаж",то сможем без проблем, перемещая персонажа и переместить всё его одеяние.

	Добавление дочерних объектов производится благодаря методу Sprite addChild(Sprite* child), при этом следует понимать, что нет никакой защиты от повторного добавление одного и того же объекта (что повлечет за собой повторное применение всех действий). При этом, в тот момент, когда срабатывает метод addChild(Sprite* child), для child вызывается метод setParent(), который устанавливает родительский объект. Родитель может быть только одним!(нет смысла позицинировать относительно двух или более объектов сразу).

	Было бы хорошо, если бы мы могли при добавлении дочернего объекта указать его имя в словаре или id,для того, чтобы получить к нему доступ в будущем. На данный момент, все дочерние объекты просто хранятся в списке.

	Спрайт по сути становиться контейнером,как и сцена.Это означает, что не нужно добавлять объекты на сцену, так как это повлечет за собой повторное выполнение одних и тех же операций (отрисовки к примеру).

-----------------------------------------------------------------------------------------------------------

*Разработка основных элементов интерфейса (не включая контейнеры): кнопки,строки,скроллбары(?).

	Кнопка должна иметь минимальный размер - размер,которому должна минимально удолетворять кнопка.Размер зависит от текста кнопки и при необходимости, кнопка расширяется к размеру, достаточному для помещения строки. Если размер текста меньше минимального размера кнопки, то кнопка не изменяет своего размера. Так же кнопка должна иметь максимальный размер - размер,дальше которого кнопка не увеличивается. Кнопка имеет четыре дополнительные функции : setOnClick(void(*)(SDL_MouseButtonEvent)),setOnHover(void(*)()),setOnRelease(void(*)()),setOnUnhover(void(*)()) , которые устанавливают поведение при различных событиях. Это означает, что для реализации поведения кнопки - не нужно её наследовать (хоть и возможно), достаточно лишь задать необходимые callback`и.

	Кнопка может при создании получать необходимые изображение различных состояний: обычное,наведенное,отпущенное. В случае отсутсвия этих изображений, будет использовано лишь обычное( которое указывается обязательно ).

	Текст кнопки - это дочерний объект кнопки

-----------------------------------------------------------------------------------------------------------
*CollisionManager - Класс,который добавляется на сцену и занимается обработкой коллизий всех объектов на сцене.Должен особым образом хранить набор объектов (к примеру сортировка по скаялрному значению радиус-вектора) и благодаря этому более быстро обрабатывать проверку на общие точки.При коллизии должен создавать новый (пользовательский) ивент event->type == COLLISION, который будет содержать два указателя на сталкивающиеся объекты. Так же вызывает событие у Sprite->onCollision(Sprite* obj), которое должно быть реализовано пользователем (или опущено).



Благодаря событию onCollision можно более легко реализовать физику:

Наследуя Sprite и создавая новый класс PhysSprite, можно заранее предсоздать различные поля : скорость,ускорение,силу и т.д.После чего,в методе onCollision задать поведение при столкновении.Например,при столкновении задать изменение вектора скорости на противоположный.Или перевод массы тела и ускорения в силу, которая добавится к другому объекту.

Пользователь так же может хранить последний объект, с которым была коллизия, после чего манипулировать этим.

Примерный интерфейс

	CollisionManager manager;
	manager.calculate();
	Sprite* getObject(Rect pos); //Возвращает объект, точка которого пересекается с заданной координатой.(В случае ошибки - возвращает nullptr).

-------------------------------------------------------------------------------------------------
*InputManager - Класс, который сохраняет и систематизирует входящие события.Упрощает работу с ними, добавляя оболочку для более понятной и простой работы.Позволяет пользователям получать ранее сохраненные события.

-----------------------------------------------------------------------------------------------------------
Замечания| С помощью восклицательного или вопросительного знака написать утверждение или вопрос
----------

!: Если при стоклновении дожны обрабатываться данные, которые зависят от другого объекта, то может возникнуть ситуация, когда поведение будет не таким, как задумано :

	Если два объекта летят друг на друга, то было бы правильно,если бы они обменялись импульсами, но если пользователь захочет напрямую присвоить скорость второго объекта, то второй уже не сможет получить скорость первого (т.к его скорость уже будет равна своей же скорости).

!: Конструктор Sprite с Image инициализирует поле Rect size неправильно.
!: При вращении мышки, т.к это тоже ивент, события будут вызываться чаще.
!: Нужно при добавлении спрайта на сцену добавить возможность выбор z координаты (что будет отображаться за кем)
!: Два вида хранения объектов: прямое добавление, добавлени с учетом z координаты.При этом, в случае с z координатой,все объекты хранятся в виде дерева.Z коордианата влияет на то,насколько левее будет добавлен объект.При отрисовке, с помощью рекурсии отрисовка начинается с самой левой ветки (считается объектом с наивысшей координатой).В случае,если объекты хранятся с одинаковой Z-позицией, они добавляются в список. 
!: Загрузка изображений происходит только по имени, лучше перед именем добавлять имя текстуры для обеспечения отсутствия конфликта имен.
!: media_manager.h loadFont принимает второй аргумент - размер щрифта,который будет проигнорирован если шрифт уже загружен


?: Не нужно ли Sprite метод типа getData(),который возвращает структуру всех данных про Sprite (не нарушая инкапсуляцию)?Это нужно для того,чтобы в структуре указать различную инфу (имя,тэг,позиция,скорость,ускорение,цвет,жёсткость,коэфициент столкновения,является ли коллизионным), при этом не обязательно, чтобы все поля были заполнены (к примеру,если спрайт не является физическим объектом).Разумеется эта функция виртиуальная.
?: Стандатный шрифт
?: Зачем Sprite size,если он хранится в image
?: Размер Sprite храниться в Rect,который хранит координаты
?: Не нужно ли проверять позицию рисуемого объекта?Есть ли смысл его рисовать,если мы его не видим?


!!:Если у Sprite задано Image,то при изменении размера (setSize) теперь изменяется структура Image image

-----------------------------------------------------------------------------------------------------------
Необходимо|
-----------

Нужно : Наследование камер с различными поведениями,возможность определения собственного поведения.
Нужно : Прозрачность Sprite
Нужно : Сейчас отрисовка Sprite при отрисовке анимаций не берет текстуру анимации,а использует переменную texture. Возможно если Animation будет возвращать Image будет лучше?
Нужно : правильно ли, что дочерние объекты спрайта отображаются самим спрайтом?
Нужно : тэги(функция setTag) - должны помочь упростить логику (к примеру при коллизии, зная тэг, можно задать поведение при столкновении со стенкой)
Нужно : два вида хранения объектов на сцене : z-позиция (в виде бинарного дерева, объекты с меньшей z-позицией, рисуются раньше), прямое добавление (рисуются в порядке добавления).
Нужно : события для сцен(onLoad,onSwitch,onFinish)


Для сцены одной из важнейших деталей является возможность быстрого поиска объекта. Понятно, что хранение данных в линейном массиве не может сполна удолетворить данным требованиям т.к поиск будет прямопропорционален кол-ву объектов. Одним из вариантов, который приходит в голову - некая сортировка объектов,к примеру по расстоянию до начала координат.Этот вариант также не является идеальным из-за того,что тогда объекты будут сортироваться "кругами", что может увеличить время поиска.

Т.к при отрисовке объектов мы проверяем, входят ли они в поле обзора, эту информацию можно сохранять в специальном контейнере, который будет хранить все объекты, которые были отрисованы.

Объекты представляются как материальные точки (любого размера): при добавлении объекта в контейнер, смотрится его размер и в случае,если он может пересекаться с другим объектом, он добавляется в список.

В конце мы получаем списки объектов - каждый элемент из этого списка может пересекаться с другим (но где этот конец).

Карта столкновений:

Добавляется объект.Он попадает в одну из четвертей.Добавляется ещё один объект,если он пересекается с первым - добавляется в список. 

Двумерный map, каждые 10 координат, к примеру - новый квадратик.То есть map[0][1] вернет тот же список, что и map[0][9] (может это будет не map а getObj(x,y)), но map[5][10] - уже другой.

Одно из решений : создается двумерный map,его значения - квадраты по 10х10 пикселей.При добавлении объекта, берется его координата, ширина и длина,а далее добавляется в необходимое кол-во квадратов.При этом каждый квадрат - это список объектов. В конце происходит пробег по всем задействованным квадратам.

Перевод в относительные координаты : передается два объекта типа спрайт или один объект типа спрайт и точка и возвращается координата в локальной системе координат.

-----------------------------------------------------------------------------------------------------------
Последнее|
----------

*Добавил child,parent , addPosition(). Обновил draw(),update() (для отрисовки детей), обновил setPosition: теперь оно изменяет и позицию всех детей на новую разницу.

29.03.19

*Не правильно, что сцена сама вызывает и проверяет для каждого своего элемента события. Теперь контроллер передает управление дальше каждому спрайту и тот уже определяет для себя события.(Теперь спрайты сами в контроллере вызывают события onClick,onDrag и т.д).

*Из сцены удалены контейнеры, которые хранят нажатые и наведенные объект из-за того, что они больше не нужны.

*Добавлен событие onDrag, onDrop , теперь пользователь может определить поведение при перетягивании и отпускании объекта.

*Все события Sprite'a (onClick,onHover,...) теперь принимают в качестве аргументе событие, это должно помочь при разработке своих функций.

*Чуть-чуть обновил тестовую сцену : теперь Block может быть перемещен с помощью мышки. 

*ActionManager == StateManager

18.03.19

*В draw() есть код, который нужно наследовать всегда (установка абсолютных позиций, отрисовка) детей.Пользователь может захотеть наследовать его,но реализовать собственную отрисовку.Нужно думать как правильно решить эту проблему.(Либо сделать так, чтобы пользователю не было необходиомости спускаться ниже абстракции либо добавлять новый интерфейс.)

29.04.19

*Когда мы загружаем что-то с помощью MediaManager'a,он при повторной загрузке одного и того же файла пытается найти его копию и в случае,если данная копия уже была загружена - возвращает на неё указатель.Если пользователю необходимо изменять параметры этого указателя,то он повлияет на всех, у кого используется эта текстура.Наиболее очевидным примером этой проблемы является шрифт - при попытке изменить размер шрифта,весь текст меняет размер т.к шрифт - это указатель. Необходимо либо не сохранять данные, либо сделать дополнительный функционал, который всегда будет возвращать новую копию,при этом придется освобождать память самостоятельно.

30.04.19

*Теперь наконец-то добавил StateManager, он хранит список всех действий, которые описываются наследниками базового класса Action.При этом пользователь может определять свои действия.Более того, добавлен стандартный коллбек, который вызывается при завершении работы действия.

*Для того, чтобы более гибко реализовать StateManager, пришлось выделить базовый класс под названием Object - класс, который описывает абсолютно любой объект, который только может быть в игровом мире(не обязательно графический,т.е камеры,спрайты и т.д).Это повлияло на изменение некоторых функций и конструкторов (на функционал не повлияло,а вот имена некоторых функций - изменились).

*Так же интереса ради, обновил немного тестовую сцену, в которой ярко демонстрируется работа StateManager'a,так же показал более практичный пример (хоть и не совсем правильный) - таймер, который рекурсивно вызывает сам себя.